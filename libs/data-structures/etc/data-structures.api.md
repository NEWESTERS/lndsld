## API Report File for "@lndsld/data-structures"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Predicate } from '@lndsld/fp';
import { Transform } from '@lndsld/fp';
import { TypeGuard } from '@lndsld/fp';

// @public (undocumented)
export type AnyKey = keyof any;

// @public (undocumented)
export function hash(item: unknown): string;

// @public (undocumented)
export type IDictionary<T = unknown> = Record<AnyKey, T>;

// @public (undocumented)
export namespace IDictionary {
    // (undocumented)
    export interface API {
        // (undocumented)
        concat<A>(dictionaryA: IDictionary<A>): <B>(dictionaryB: IDictionary<B>) => IDictionary<A | B>;
        // (undocumented)
        create<T>(): IDictionary<T>;
        // (undocumented)
        filter: {
            <A, B extends A>(predicate: TypeGuard<A, B>): Transform<IDictionary<A>, IDictionary<B>>;
            <A>(predicate: Predicate<A>): Transform<IDictionary<A>, IDictionary<A>>;
        };
        // (undocumented)
        get(key: AnyKey): <T>(dictionary: IDictionary<T>) => T | undefined;
        // (undocumented)
        getLength(dictionary: IDictionary): number;
        // (undocumented)
        getMany(keys: AnyKey[]): <T>(dictionary: IDictionary<T>) => T[];
        // (undocumented)
        isEmpty(dictionary: IDictionary): boolean;
        // (undocumented)
        map<A, B>(callback: (item: A, key: AnyKey) => B): Transform<IDictionary<A>, IDictionary<B>>;
        // (undocumented)
        modify<T>(key: AnyKey, callback: Transform<T>): Transform<IDictionary<T>>;
        // (undocumented)
        removeKey(key: AnyKey): <T>(dictionary: IDictionary<T>) => IDictionary<T>;
        // (undocumented)
        set<V>(key: AnyKey, value: V): <T>(dictionary: IDictionary<T>) => V extends T ? IDictionary<T> : IDictionary<V | T>;
        // (undocumented)
        toList<T>(dictionary: IDictionary<T>): IList<T>;
    }
    // (undocumented)
    export type InferValue<C> = C extends IDictionary<infer T> ? T : never;
}

// @public (undocumented)
export const IDictionary: IDictionary.API;

// @public (undocumented)
export interface IKeyTree {
    // (undocumented)
    readonly rootKey: AnyKey;
    // (undocumented)
    readonly structure: IDictionary<ISet<AnyKey>>;
}

// @public (undocumented)
export namespace IKeyTree {
    // (undocumented)
    export interface API {
        // (undocumented)
        addChild(parentKey: AnyKey, childKey: AnyKey): Transform<IKeyTree>;
        // (undocumented)
        create(rootKey: AnyKey): IKeyTree;
        // (undocumented)
        getChildren(parentKey: AnyKey): (tree: IKeyTree) => ISet<AnyKey> | undefined;
    }
}

// @public (undocumented)
export const IKeyTree: IKeyTree.API;

// @public (undocumented)
export type IList<T = unknown> = IStack<T>;

// @public (undocumented)
export namespace IList {
    // (undocumented)
    export interface API extends IStack.API {
        // (undocumented)
        create<T>(...parameters: T[]): IList<T>;
        // (undocumented)
        filter: {
            <A, B extends A>(predicate: TypeGuard<A, B>): Transform<IList<A>, IList<B>>;
            <A>(predicate: Predicate<A>): Transform<IList<A>, IList<A>>;
        };
        // (undocumented)
        removeIndex(index: number): <T>(list: IList<T>) => IList<T>;
        // (undocumented)
        sort<A>(comparator: (itemA: A, itemB: A) => number): Transform<IList<A>>;
    }
    // (undocumented)
    export type InferValue<L> = IStack.InferValue<L>;
}

// @public (undocumented)
export const IList: IList.API;

// @public (undocumented)
export interface IOrderedKeyTree<K extends AnyKey = string> {
    // (undocumented)
    readonly rootKey: K;
    // (undocumented)
    readonly structure: IDictionary;
}

// @public (undocumented)
export namespace IOrderedKeyTree {
    // (undocumented)
    export interface API {
        // (undocumented)
        create<K extends AnyKey = string>(rootKey: K): IOrderedKeyTree<K>;
        // (undocumented)
        getChildren(parentKey: AnyKey): (tree: IOrderedKeyTree) => IList<AnyKey> | undefined;
        // (undocumented)
        pushChild<K extends AnyKey>(parentKey: K, childKey: K): Transform<IOrderedKeyTree<K>>;
    }
    // (undocumented)
    export type InferValue<S> = S extends IOrderedKeyTree<infer T> ? T : never;
}

// @public (undocumented)
export const IOrderedKeyTree: IOrderedKeyTree.API;

// @public (undocumented)
export interface IOrderedTree<V = unknown> {
    // (undocumented)
    items: IDictionary<V>;
    // (undocumented)
    keys: IOrderedKeyTree;
}

// @public (undocumented)
export namespace IOrderedTree {
    // (undocumented)
    export interface API {
        // (undocumented)
        create<V>(rootKey: AnyKey, rootItem: V): IOrderedTree<V>;
        // (undocumented)
        getChildren(parentKey: AnyKey): <V>(tree: IOrderedTree<V>) => V[] | undefined;
        // (undocumented)
        getChildrenKeys(parentKey: AnyKey): (tree: IOrderedTree) => AnyKey[] | undefined;
        // (undocumented)
        pushChild<V>(parentKey: AnyKey, childKey: AnyKey, childItem: V): Transform<IOrderedTree<V>>;
    }
    // (undocumented)
    export type InferValue<C> = C extends IOrderedTree<infer T> ? T : never;
}

// @public (undocumented)
export const IOrderedTree: IOrderedTree.API;

// @public (undocumented)
export namespace IRecord {
    // (undocumented)
    export interface API {
        // (undocumented)
        get<K extends AnyKey>(key: K): <R extends {
            [key in K]: unknown;
        }>(record: R) => R[K];
        // (undocumented)
        getKeys<T extends AnyKey>(record: Record<T, unknown>): T[];
        // (undocumented)
        hasKey<T extends AnyKey>(key: T): (record: object) => record is Record<T, unknown>;
        // (undocumented)
        isRecord(value: unknown): value is Record<AnyKey, unknown>;
        // (undocumented)
        modify<K extends AnyKey, V1, V2>(key: K, callback: Transform<V1, V2>): <R extends {}>(record: R) => Readonly<Omit<R, K> & Record<K, V2>>;
        // (undocumented)
        removeKey<K extends AnyKey>(key: K): <R extends {}>(record: R) => Readonly<Omit<R, K>>;
        // (undocumented)
        set<K extends AnyKey, V>(key: K, value: V): <R extends {}>(record: R) => Readonly<Omit<R, K> & Record<K, V>>;
    }
}

// @public (undocumented)
export const IRecord: IRecord.API;

// @public (undocumented)
export type ISet<T = unknown> = Record<string, T>;

// @public (undocumented)
export namespace ISet {
    // (undocumented)
    export interface API {
        // (undocumented)
        add<T>(item: T): <T2>(set: ISet<T2>) => ISet<T2 | T>;
        // (undocumented)
        concat<A>(setA: ISet<A>): <B>(setB: ISet<B>) => ISet<A | B>;
        // (undocumented)
        create<T>(...items: T[]): ISet<T>;
        // (undocumented)
        exclude<A>(exclusion: ISet<A>): (set: ISet<A>) => ISet<A>;
        // (undocumented)
        find<A>(predicate: Predicate<A>): Transform<ISet<A>, A | undefined>;
        // (undocumented)
        fromList<T>(list: IList<T>): ISet<T>;
        // (undocumented)
        getLength(set: ISet<unknown>): number;
        // (undocumented)
        has(item: any): (set: ISet) => boolean;
        // (undocumented)
        isEmpty(set: ISet<unknown>): boolean;
        // (undocumented)
        map<A, B>(callback: (item: A) => B): (set: ISet<A>) => ISet<B>;
        // (undocumented)
        remove: <T>(item: T) => Transform<ISet<T>>;
        // (undocumented)
        toList<T>(set: ISet<T>): IList<T>;
    }
    // (undocumented)
    export type InferValue<S> = S extends ISet<infer T> ? T : never;
}

// @public (undocumented)
export const ISet: ISet.API;

// @public (undocumented)
export type IStack<T = unknown> = Readonly<Array<T>>;

// @public (undocumented)
export namespace IStack {
    // (undocumented)
    export interface API {
        // (undocumented)
        concat<A>(stackA: IStack<A>): <B>(stackB: IStack<B>) => IStack<A | B>;
        // (undocumented)
        create<T>(): IStack<T>;
        // (undocumented)
        find: {
            <A, B extends A>(predicate: TypeGuard<A, B>): Transform<IStack<A>, B | undefined>;
            (predicate: Predicate<unknown>): <T>(stack: IStack<T>) => T | undefined;
            <A>(predicate: Predicate<A>): Transform<IStack<A>, A | undefined>;
        };
        // (undocumented)
        getLast<T>(stack: IStack<T>): T | undefined;
        // (undocumented)
        getLength(stack: IStack): number;
        // (undocumented)
        has<T>(item: T): Transform<IStack<T>, boolean>;
        // (undocumented)
        map<A, B>(callback: (item: A, index: number) => B): Transform<IStack<A>, IStack<B>>;
        // (undocumented)
        pop<T>(stack: IStack<T>): IStack<T>;
        // (undocumented)
        push<T>(item: T): Transform<IStack<T>, IStack<T>>;
    }
    // (undocumented)
    export type InferValue<S> = S extends IStack<infer T> ? T : never;
}

// @public (undocumented)
export const IStack: IStack.API;

// @public (undocumented)
export interface ITree<V = unknown> {
    // (undocumented)
    readonly items: IDictionary<V>;
    // (undocumented)
    readonly keys: IKeyTree;
}

// @public (undocumented)
export namespace ITree {
    // (undocumented)
    export interface API {
        // (undocumented)
        addChild<V>(parentKey: AnyKey, childKey: AnyKey, childItem: V): Transform<ITree<V>>;
        // (undocumented)
        create<V>(rootKey: AnyKey, rootItem: V): ITree<V>;
        // (undocumented)
        getChildren(parentKey: AnyKey): <V>(tree: ITree<V>) => V[];
        // (undocumented)
        getChildrenKeys(parentKey: AnyKey): (tree: ITree) => ISet<AnyKey>;
    }
    // (undocumented)
    export type InferValue<C> = C extends ITree<infer T> ? T : never;
}

// @public (undocumented)
export const ITree: ITree.API;

// (No @packageDocumentation comment for this package)

```
