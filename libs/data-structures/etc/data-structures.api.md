## API Report File for "@lndsld/data-structures"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Predicate } from '@lndsld/fp';
import { Transform } from '@lndsld/fp';
import { TypeGuard } from '@lndsld/fp';

// @public (undocumented)
export type AnyKey = keyof any;

// @public
function create<T>(...parameters: T[]): IList<T>;

// @public
function filter<A, B extends A>(predicate: TypeGuard<A, B>): Transform<IList<A>, IList<B>>;

// @public (undocumented)
function filter<A>(predicate: Predicate<A>): Transform<IList<A>, IList<A>>;

// @public (undocumented)
function get<K extends AnyKey>(key: K): <R extends IRecord>(record: R) => R extends IRecord<K> ? R[K] : unknown;

// @public (undocumented)
function getKeys<T extends AnyKey>(record: IRecord<T>): T[];

// @public (undocumented)
export function hash(item: unknown): string;

// Warning: (ae-forgotten-export) The symbol "HasKeyPredicate" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function hasKey<K extends AnyKey>(key: K): HasKeyPredicate<K>;

// @public (undocumented)
export type IDictionary<T = unknown> = Record<AnyKey, T>;

// @public (undocumented)
export namespace IDictionary {
    // (undocumented)
    export interface API {
        // (undocumented)
        concat<A>(dictionaryA: IDictionary<A>): <B>(dictionaryB: IDictionary<B>) => IDictionary<A | B>;
        // (undocumented)
        create<T>(): IDictionary<T>;
        // (undocumented)
        filter: {
            <A, B extends A>(predicate: TypeGuard<A, B>): Transform<IDictionary<A>, IDictionary<B>>;
            <A>(predicate: Predicate<A>): Transform<IDictionary<A>, IDictionary<A>>;
        };
        // (undocumented)
        get(key: AnyKey): <T>(dictionary: IDictionary<T>) => T | undefined;
        // (undocumented)
        getLength(dictionary: IDictionary): number;
        // (undocumented)
        getMany(keys: AnyKey[]): <T>(dictionary: IDictionary<T>) => T[];
        // (undocumented)
        isEmpty(dictionary: IDictionary): boolean;
        // (undocumented)
        map<A, B>(callback: (item: A, key: AnyKey) => B): Transform<IDictionary<A>, IDictionary<B>>;
        // (undocumented)
        modify<T>(key: AnyKey, callback: Transform<T>): Transform<IDictionary<T>>;
        // (undocumented)
        removeKey(key: AnyKey): <T>(dictionary: IDictionary<T>) => IDictionary<T>;
        // (undocumented)
        set<V>(key: AnyKey, value: V): <T>(dictionary: IDictionary<T>) => V extends T ? IDictionary<T> : IDictionary<V | T>;
        // (undocumented)
        toList<T>(dictionary: IDictionary<T>): IList<T>;
    }
    // (undocumented)
    export type InferValue<C> = C extends IDictionary<infer T> ? T : never;
}

// @public (undocumented)
export const IDictionary: IDictionary.API;

// @public (undocumented)
export interface IKeyTree {
    // (undocumented)
    readonly rootKey: AnyKey;
    // (undocumented)
    readonly structure: IDictionary<ISet<AnyKey>>;
}

// @public (undocumented)
export namespace IKeyTree {
    // (undocumented)
    export interface API {
        // (undocumented)
        addChild(parentKey: AnyKey, childKey: AnyKey): Transform<IKeyTree>;
        // (undocumented)
        create(rootKey: AnyKey): IKeyTree;
        // (undocumented)
        getChildren(parentKey: AnyKey): (tree: IKeyTree) => ISet<AnyKey> | undefined;
    }
}

// @public (undocumented)
export const IKeyTree: IKeyTree.API;

// @public (undocumented)
export type IList<T = unknown> = IStack<T>;

// @public (undocumented)
export namespace IList {
    // (undocumented)
    export type InferValue<L> = IStack.InferValue<L>;
}

// @public (undocumented)
export const IList: {
    create: typeof methods_2.create;
    filter: typeof methods_2.filter;
    removeIndex: typeof methods_2.removeIndex;
    sort: typeof methods_2.sort;
    push<T>(item: T): Transform<readonly T[], readonly T[]>;
    pop<T_1>(stack: readonly T_1[]): readonly T_1[];
    find: {
        <A, B extends A>(predicate: TypeGuard<A, B>): Transform<readonly A[], B | undefined>;
        (predicate: Predicate<unknown>): <T_2>(stack: readonly T_2[]) => T_2 | undefined;
        <A_1>(predicate: Predicate<A_1>): Transform<readonly A_1[], A_1 | undefined>;
    };
    has<T_3>(item: T_3): Transform<readonly T_3[], boolean>;
    getLength(stack: readonly unknown[]): number;
    getLast<T_4>(stack: readonly T_4[]): T_4 | undefined;
    concat<A_2>(stackA: readonly A_2[]): <B_1>(stackB: readonly B_1[]) => readonly (A_2 | B_1)[];
    map<A_3, B_2>(callback: (item: A_3, index: number) => B_2): Transform<readonly A_3[], readonly B_2[]>;
};

// @public (undocumented)
export interface IOrderedKeyTree<K extends AnyKey = string> {
    // (undocumented)
    readonly rootKey: K;
    // (undocumented)
    readonly structure: IDictionary;
}

// @public (undocumented)
export namespace IOrderedKeyTree {
    // (undocumented)
    export interface API {
        // (undocumented)
        create<K extends AnyKey = string>(rootKey: K): IOrderedKeyTree<K>;
        // (undocumented)
        getChildren(parentKey: AnyKey): (tree: IOrderedKeyTree) => IList<AnyKey> | undefined;
        // (undocumented)
        pushChild<K extends AnyKey>(parentKey: K, childKey: K): Transform<IOrderedKeyTree<K>>;
    }
    // (undocumented)
    export type InferValue<S> = S extends IOrderedKeyTree<infer T> ? T : never;
}

// @public (undocumented)
export const IOrderedKeyTree: IOrderedKeyTree.API;

// @public (undocumented)
export interface IOrderedTree<V = unknown> {
    // (undocumented)
    items: IDictionary<V>;
    // (undocumented)
    keys: IOrderedKeyTree;
}

// @public (undocumented)
export namespace IOrderedTree {
    // (undocumented)
    export interface API {
        // (undocumented)
        create<V>(rootKey: AnyKey, rootItem: V): IOrderedTree<V>;
        // (undocumented)
        getChildren(parentKey: AnyKey): <V>(tree: IOrderedTree<V>) => V[] | undefined;
        // (undocumented)
        getChildrenKeys(parentKey: AnyKey): (tree: IOrderedTree) => AnyKey[] | undefined;
        // (undocumented)
        pushChild<V>(parentKey: AnyKey, childKey: AnyKey, childItem: V): Transform<IOrderedTree<V>>;
    }
    // (undocumented)
    export type InferValue<C> = C extends IOrderedTree<infer T> ? T : never;
}

// @public (undocumented)
export const IOrderedTree: IOrderedTree.API;

// @public (undocumented)
export type IRecord<K extends AnyKey = never, V = unknown> = Readonly<Record<K, V>>;

// @public (undocumented)
export namespace IRecord {
    // (undocumented)
    export type AddProperty<R extends IRecord, K extends AnyKey, V> = K extends keyof R ? never : R & IRecord<K, V>;
    // (undocumented)
    export type OverrideProperty<R extends IRecord, K extends AnyKey, V> = AddProperty<Omit<R, K>, K, V>;
}

// Warning: (ae-forgotten-export) The symbol "methods" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const IRecord: typeof methods;

// @public (undocumented)
export type ISet<T = unknown> = Record<string, T>;

// @public (undocumented)
export namespace ISet {
    // (undocumented)
    export interface API {
        // (undocumented)
        add<T>(item: T): <T2>(set: ISet<T2>) => ISet<T2 | T>;
        // (undocumented)
        concat<A>(setA: ISet<A>): <B>(setB: ISet<B>) => ISet<A | B>;
        // (undocumented)
        create<T>(...items: T[]): ISet<T>;
        // (undocumented)
        exclude<A>(exclusion: ISet<A>): (set: ISet<A>) => ISet<A>;
        // (undocumented)
        find<A>(predicate: Predicate<A>): Transform<ISet<A>, A | undefined>;
        // (undocumented)
        fromList<T>(list: IList<T>): ISet<T>;
        // (undocumented)
        getLength(set: ISet<unknown>): number;
        // (undocumented)
        has(item: any): (set: ISet) => boolean;
        // (undocumented)
        isEmpty(set: ISet<unknown>): boolean;
        // (undocumented)
        map<A, B>(callback: (item: A) => B): (set: ISet<A>) => ISet<B>;
        // (undocumented)
        remove: <T>(item: T) => Transform<ISet<T>>;
        // (undocumented)
        toList<T>(set: ISet<T>): IList<T>;
    }
    // (undocumented)
    export type InferValue<S> = S extends ISet<infer T> ? T : never;
}

// @public (undocumented)
export const ISet: ISet.API;

// @public (undocumented)
function isRecord(value: unknown): value is IRecord;

// @public (undocumented)
export type IStack<T = unknown> = Readonly<Array<T>>;

// @public (undocumented)
export namespace IStack {
    // (undocumented)
    export interface API {
        // (undocumented)
        concat<A>(stackA: IStack<A>): <B>(stackB: IStack<B>) => IStack<A | B>;
        // (undocumented)
        create<T>(): IStack<T>;
        // (undocumented)
        find: {
            <A, B extends A>(predicate: TypeGuard<A, B>): Transform<IStack<A>, B | undefined>;
            (predicate: Predicate<unknown>): <T>(stack: IStack<T>) => T | undefined;
            <A>(predicate: Predicate<A>): Transform<IStack<A>, A | undefined>;
        };
        // (undocumented)
        getLast<T>(stack: IStack<T>): T | undefined;
        // (undocumented)
        getLength(stack: IStack): number;
        // (undocumented)
        has<T>(item: T): Transform<IStack<T>, boolean>;
        // (undocumented)
        map<A, B>(callback: (item: A, index: number) => B): Transform<IStack<A>, IStack<B>>;
        // (undocumented)
        pop<T>(stack: IStack<T>): IStack<T>;
        // (undocumented)
        push<T>(item: T): Transform<IStack<T>, IStack<T>>;
    }
    // (undocumented)
    export type InferValue<S> = S extends IStack<infer T> ? T : never;
}

// @public (undocumented)
export const IStack: IStack.API;

// @public (undocumented)
export interface ITree<V = unknown> {
    // (undocumented)
    readonly items: IDictionary<V>;
    // (undocumented)
    readonly keys: IKeyTree;
}

// @public (undocumented)
export namespace ITree {
    // (undocumented)
    export interface API {
        // (undocumented)
        addChild<V>(parentKey: AnyKey, childKey: AnyKey, childItem: V): Transform<ITree<V>>;
        // (undocumented)
        create<V>(rootKey: AnyKey, rootItem: V): ITree<V>;
        // (undocumented)
        getChildren(parentKey: AnyKey): <V>(tree: ITree<V>) => V[];
        // (undocumented)
        getChildrenKeys(parentKey: AnyKey): (tree: ITree) => ISet<AnyKey>;
    }
    // (undocumented)
    export type InferValue<C> = C extends ITree<infer T> ? T : never;
}

// @public (undocumented)
export const ITree: ITree.API;

// Warning: (ae-forgotten-export) The symbol "ModifyTransform" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function modify<K extends AnyKey, V1, V2 = V1>(key: K, callback: Transform<V1, V2>): ModifyTransform<K, V1, V2>;

// Warning: (ae-forgotten-export) The symbol "OmitTransform" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function omit<T extends AnyKey>(keys: T[]): OmitTransform<T>;

// Warning: (ae-forgotten-export) The symbol "PickTransform" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function pick<T extends AnyKey>(keys: T[]): PickTransform<T>;

// @public
function removeIndex(index: number): <T>(list: IList<T>) => IList<T>;

// Warning: (ae-forgotten-export) The symbol "RemoveKeyTransform" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function removeKey<K extends AnyKey>(key: K): RemoveKeyTransform<K>;

// Warning: (ae-forgotten-export) The symbol "SetTransform" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function set<K extends AnyKey, V>(key: K, value: V): SetTransform<K, V>;

// @public
function sort<A>(comparator: (itemA: A, itemB: A) => number): Transform<IList<A>>;

// Warnings were encountered during analysis:
//
// temp/types/structures/IList/IList.d.ts:8:5 - (ae-forgotten-export) The symbol "methods" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
